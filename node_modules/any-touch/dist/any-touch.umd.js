(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.AnyTouch = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    var default_1 = (function () {
        function default_1() {
            this.listenersMap = {};
        }
        default_1.prototype.on = function (eventName, listener, beforeEmit) {
            var e_1, _a;
            var eventNames = Array.isArray(eventName) ? eventName : [eventName];
            try {
                for (var eventNames_1 = __values(eventNames), eventNames_1_1 = eventNames_1.next(); !eventNames_1_1.done; eventNames_1_1 = eventNames_1.next()) {
                    var name = eventNames_1_1.value;
                    if (void 0 === this.listenersMap[name]) {
                        this.listenersMap[name] = [];
                    }
                    listener.beforeEmit = beforeEmit;
                    this.listenersMap[name].push(listener);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (eventNames_1_1 && !eventNames_1_1.done && (_a = eventNames_1.return)) _a.call(eventNames_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return this;
        };
        default_1.prototype.emit = function (eventName, payload) {
            var e_2, _a;
            var listeners = this.listenersMap[eventName];
            if (void 0 !== listeners && 0 < listeners.length) {
                try {
                    for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
                        var listener = listeners_1_1.value;
                        if (void 0 === listener.beforeEmit) {
                            listener(payload);
                        }
                        else if (void 0 !== payload && listener.beforeEmit(payload)) {
                            listener(payload);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        default_1.prototype.off = function (eventName, listener) {
            var listeners = this.listenersMap[eventName];
            if (void 0 !== listeners) {
                if (void 0 === listener) {
                    delete this.listenersMap[eventName];
                }
                else {
                    var index = listeners.findIndex(function (fn) { return fn === listener; });
                    listeners.splice(index, 1);
                }
            }
        };
        default_1.prototype.destroy = function () {
            this.listenersMap = {};
        };
        return default_1;
    }());

    var ObjectToString = Object.prototype.toString;
    function isRegExp(input) {
        return '[object RegExp]' === ObjectToString.call(input);
    }
    function isFunction(input) {
        return '[object Function]' === ObjectToString.call(input);
    }

    var CLIENT_X = 'clientX';
    var CLIENT_Y = 'clientY';
    var COMPUTE_INTERVAL = 16;
    var INPUT_START = 'start';
    var INPUT_MOVE = 'move';
    var INPUT_CANCEL = 'cancel';
    var INPUT_END = 'end';
    var DIRECTION_LEFT = 'left';
    var DIRECTION_RIGHT = 'right';
    var DIRECTION_UP = 'up';
    var DIRECTION_DOWN = 'down';
    var TOUCH = 'touch';
    var MOUSE = 'mouse';
    var TOUCH_START = TOUCH + INPUT_START;
    var TOUCH_MOVE = TOUCH + INPUT_MOVE;
    var TOUCH_END = TOUCH + INPUT_END;
    var TOUCH_CANCEL = TOUCH + INPUT_CANCEL;
    var MOUSE_UP = MOUSE + DIRECTION_UP;
    var MOUSE_MOVE = MOUSE + INPUT_MOVE;
    var MOUSE_DOWN = MOUSE + DIRECTION_DOWN;
    var STATUS_POSSIBLE = 'p';
    var STATUS_START = INPUT_START;
    var STATUS_MOVE = INPUT_MOVE;
    var STATUS_END = INPUT_END;
    var STATUS_RECOGNIZED = 'r';
    var STATUS_FAILED = 'f';
    var STATUS_CANCELLED = INPUT_CANCEL;

    function round2(n) {
        return Math.round(n * 100) / 100;
    }

    function inputCreator () {
        var id = 0;
        var prevInput;
        var activeInput;
        var startInput;
        var startMultiInput;
        return function (basicsInput) {
            prevInput = activeInput;
            if (void 0 !== basicsInput) {
                id = Number.MAX_SAFE_INTEGER > id ? ++id : 1;
                var pureInput = extendInput(basicsInput, id);
                activeInput = pureInput;
                var isStart = pureInput.isStart, pointLength = pureInput.pointLength;
                if (isStart) {
                    startInput = pureInput;
                    prevInput = void 0;
                    if (1 < pointLength) {
                        startMultiInput = pureInput;
                    }
                    else {
                        startMultiInput = void 0;
                    }
                }
                return __assign(__assign({}, pureInput), { prevInput: prevInput, startMultiInput: startMultiInput, startInput: startInput });
            }
        };
    }
    function getCenter(points) {
        var length = points.length;
        if (0 < length) {
            if (1 === length) {
                var _a = points[0], clientX = _a.clientX, clientY = _a.clientY;
                return { x: Math.round(clientX), y: Math.round(clientY) };
            }
            var countPoint = points.reduce(function (countPoint, point) {
                countPoint.x += point[CLIENT_X];
                countPoint.y += point[CLIENT_Y];
                return countPoint;
            }, { x: 0, y: 0 });
            return { x: Math.round(countPoint.x / length), y: Math.round(countPoint.y / length) };
        }
    }
    function extendInput(basicsInput, id) {
        var stage = basicsInput.stage, points = basicsInput.points, changedPoints = basicsInput.changedPoints, nativeEvent = basicsInput.nativeEvent;
        var pointLength = points.length;
        var isStart = INPUT_START === stage;
        var isEnd = (INPUT_END === stage && 0 === pointLength) || INPUT_CANCEL === stage;
        var timestamp = Date.now();
        var _a = getCenter(points) || getCenter(changedPoints), x = _a.x, y = _a.y;
        var currentTarget = nativeEvent.currentTarget;
        return Object.assign(basicsInput, {
            id: id,
            x: x, y: y,
            timestamp: timestamp,
            isStart: isStart, isEnd: isEnd,
            pointLength: pointLength,
            currentTarget: currentTarget,
            getOffset: function (el) {
                if (el === void 0) { el = currentTarget; }
                var rect = el.getBoundingClientRect();
                return { x: x - Math.round(rect.left), y: y - Math.round(rect.top) };
            }
        });
    }

    function mouse () {
        var prevPoints;
        var isPressed = false;
        var _target = null;
        var createInput = inputCreator();
        return function (event) {
            var clientX = event.clientX, clientY = event.clientY, type = event.type, button = event.button, target = event.target;
            var points = [{ clientX: clientX, clientY: clientY, target: target }];
            var stage;
            if (MOUSE_DOWN === type && 0 === button) {
                _target = target;
                isPressed = true;
                stage = INPUT_START;
            }
            else if (isPressed) {
                if (MOUSE_MOVE === type) {
                    stage = INPUT_MOVE;
                }
                else if (MOUSE_UP === type) {
                    points = [];
                    stage = INPUT_END;
                    isPressed = false;
                }
            }
            var changedPoints = prevPoints || [{ clientX: clientX, clientY: clientY, target: target }];
            prevPoints = [{ clientX: clientX, clientY: clientY, target: target }];
            if (void 0 !== stage) {
                return createInput({
                    stage: stage,
                    changedPoints: changedPoints,
                    points: points,
                    target: _target,
                    targets: [_target],
                    nativeEvent: event
                });
            }
        };
    }

    function touch (el) {
        var createInput = inputCreator();
        return function (event) {
            var targets = [];
            var points = [];
            Array.from(event.touches).forEach(function (_a) {
                var clientX = _a.clientX, clientY = _a.clientY, target = _a.target;
                if (el === null || el === void 0 ? void 0 : el.contains(target)) {
                    targets.push(target);
                    points.push({ clientX: clientX, clientY: clientY, target: target });
                }
            });
            var changedPoints = Array.from(event.changedTouches).map(function (_a) {
                var clientX = _a.clientX, clientY = _a.clientY, target = _a.target;
                return ({ clientX: clientX, clientY: clientY, target: target });
            });
            return createInput({
                stage: event.type.replace('touch', ''),
                changedPoints: changedPoints,
                points: points,
                nativeEvent: event,
                target: event.target,
                targets: targets
            });
        };
    }

    function dispatchDomEvent (el, payload, eventInit) {
        var target = payload.target, currentTarget = payload.currentTarget, type = payload.type, data = __rest(payload, ["target", "currentTarget", "type"]);
        var event;
        if (document.createEvent) {
            event = document.createEvent('HTMLEvents');
            event.initEvent(type, eventInit === null || eventInit === void 0 ? void 0 : eventInit.bubbles, eventInit === null || eventInit === void 0 ? void 0 : eventInit.cancelable);
        }
        else {
            event = new Event(type, eventInit);
        }
        Object.assign(event, data, {
            match: function () {
                return payload.targets.every(function (target) {
                    return event.currentTarget.contains(target);
                });
            }
        });
        return el.dispatchEvent(event);
    }

    function canPreventDefault (event, options) {
        if (!options.preventDefault)
            return false;
        var preventDefault = true;
        if (null !== event.target) {
            var preventDefaultExclude = options.preventDefaultExclude;
            if (isRegExp(preventDefaultExclude)) {
                if ('tagName' in event.target) {
                    var tagName = event.target.tagName;
                    preventDefault = !preventDefaultExclude.test(tagName);
                }
            }
            else if (isFunction(preventDefaultExclude)) {
                preventDefault = !preventDefaultExclude(event);
            }
        }
        return preventDefault;
    }

    var TOUCH_EVENTS = [TOUCH_START, TOUCH_MOVE, TOUCH_END, TOUCH_CANCEL];
    function bindElement (el, catchEvent, options) {
        TOUCH_EVENTS.forEach(function (eventName) {
            el.addEventListener(eventName, catchEvent, options);
        });
        el.addEventListener(MOUSE_DOWN, catchEvent, options);
        window.addEventListener(MOUSE_MOVE, catchEvent, options);
        window.addEventListener(MOUSE_UP, catchEvent, options);
        return function () {
            TOUCH_EVENTS.forEach(function (eventName) {
                el.removeEventListener(eventName, catchEvent);
            });
            el.removeEventListener(MOUSE_DOWN, catchEvent, options);
            window.removeEventListener(MOUSE_MOVE, catchEvent, options);
            window.removeEventListener(MOUSE_UP, catchEvent, options);
        };
    }

    var AT_AFTER = 'at:after';
    function emit2 (at, payload) {
        var type = payload.type, target = payload.target;
        at.emit(type, payload);
        at.emit(AT_AFTER, payload);
        if (!!at.options.domEvents
            && void 0 !== at.el
            && null !== target) {
            dispatchDomEvent(target, payload, at.options.domEvents);
            dispatchDomEvent(target, __assign(__assign({}, payload), { _type: payload.type, type: AT_AFTER }), at.options.domEvents);
        }
    }

    var DEFAULT_OPTIONS = {
        domEvents: { bubbles: true, cancelable: true },
        preventDefault: true,
        preventDefaultExclude: /^(?:INPUT|TEXTAREA|BUTTON|SELECT)$/,
    };
    var AT = "at";
    var AnyTouch = (function (_super) {
        __extends(AnyTouch, _super);
        function AnyTouch(el, options) {
            var e_1, _a, _b;
            var _this = _super.call(this) || this;
            _this._$computeFunctionMap = {};
            _this._$recognizerMap = {};
            _this._$recognizers = [];
            _this.el = el;
            _this.options = __assign(__assign({}, DEFAULT_OPTIONS), options);
            try {
                for (var _c = __values(AnyTouch._$Recognizers), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var _e = __read(_d.value, 2), Recognizer_1 = _e[0], options_1 = _e[1];
                    _this.use(Recognizer_1, options_1);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var createInputFromTouch = touch(_this.el);
            var createInputFromMouse = mouse();
            _this._$inputCreatorMap = (_b = {},
                _b[TOUCH_START] = createInputFromTouch,
                _b[TOUCH_MOVE] = createInputFromTouch,
                _b[TOUCH_END] = createInputFromTouch,
                _b[TOUCH_CANCEL] = createInputFromTouch,
                _b[MOUSE_DOWN] = createInputFromMouse,
                _b[MOUSE_MOVE] = createInputFromMouse,
                _b[MOUSE_UP] = createInputFromMouse,
                _b);
            if (void 0 !== el) {
                el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
                var supportsPassive_1 = false;
                try {
                    var opts = {};
                    Object.defineProperty(opts, 'passive', ({
                        get: function () {
                            supportsPassive_1 = true;
                        }
                    }));
                    window.addEventListener('_', function () { return void 0; }, opts);
                }
                catch (_f) { }
                _this.on('unbind', bindElement(el, _this.catchEvent.bind(_this), !_this.options.preventDefault && supportsPassive_1 ? { passive: true } : false));
            }
            return _this;
        }
        AnyTouch.prototype.target = function (el) {
            var _this = this;
            return {
                on: function (eventName, listener) {
                    _this.on(eventName, listener, function (event) {
                        var targets = event.targets;
                        return targets.every(function (target) { return el.contains(target); });
                    });
                }
            };
        };
        AnyTouch.prototype.catchEvent = function (event) {
            var e_2, _a;
            var _this = this;
            var stopPropagation = function () { return event.stopPropagation(); };
            var preventDefault = function () { return event.preventDefault(); };
            var stopImmediatePropagation = function () { return event.stopImmediatePropagation(); };
            if (canPreventDefault(event, this.options)) {
                preventDefault();
            }
            var input = this._$inputCreatorMap[event.type](event);
            if (void 0 !== input) {
                var AT_WITH_STATUS = AT + ':' + input.stage;
                this.emit(AT, input);
                this.emit(AT_WITH_STATUS, input);
                var domEvents = this.options.domEvents;
                if (false !== domEvents) {
                    var target = event.target;
                    if (null !== target) {
                        dispatchDomEvent(target, __assign(__assign({}, input), { type: AT }), domEvents);
                        dispatchDomEvent(target, __assign(__assign({}, input), { type: AT_WITH_STATUS }), domEvents);
                    }
                }
                var computed_1 = input;
                for (var k in this._$computeFunctionMap) {
                    Object.assign(computed_1, this._$computeFunctionMap[k](computed_1));
                }
                var _loop_1 = function (recognizer) {
                    if (recognizer.disabled)
                        return "continue";
                    recognizer.recognize(computed_1, function (type) {
                        var payload = __assign(__assign({}, computed_1), { type: type, name: recognizer.name, stopPropagation: stopPropagation,
                            preventDefault: preventDefault,
                            stopImmediatePropagation: stopImmediatePropagation });
                        Object === null || Object === void 0 ? void 0 : Object.freeze(payload);
                        if (void 0 === _this.beforeEachHook) {
                            emit2(_this, payload);
                        }
                        else {
                            _this.beforeEachHook(recognizer, _this._$recognizerMap, function () {
                                emit2(_this, payload);
                            });
                        }
                    });
                };
                try {
                    for (var _b = __values(this._$recognizers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var recognizer = _c.value;
                        _loop_1(recognizer);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        AnyTouch.prototype.use = function (Recognizer, recognizerOptions) {
            var e_3, _a;
            var name = recognizerOptions === null || recognizerOptions === void 0 ? void 0 : recognizerOptions.name;
            if (void 0 !== name && void 0 !== this._$recognizerMap[name])
                return;
            var recognizer = new Recognizer(recognizerOptions);
            try {
                for (var _b = __values(recognizer.computeFunctions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var createComputeFunction = _c.value;
                    var _id = createComputeFunction._id;
                    if (void 0 === this._$computeFunctionMap[_id]) {
                        this._$computeFunctionMap[_id] = createComputeFunction();
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this._$recognizerMap[recognizer.name] = recognizer;
            this._$recognizers.push(this._$recognizerMap[recognizer.name]);
        };
        AnyTouch.prototype.removeUse = function (recognizerName) {
            var e_4, _a;
            if (void 0 === recognizerName) {
                this._$recognizers = [];
                this._$recognizerMap = {};
            }
            else {
                try {
                    for (var _b = __values(this._$recognizers.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _d = __read(_c.value, 2), index = _d[0], recognizer = _d[1];
                        if (recognizerName === recognizer.options.name) {
                            this._$recognizers.splice(index, 1);
                            delete this._$recognizerMap[recognizerName];
                            break;
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        };
        AnyTouch.prototype.beforeEach = function (hook) {
            this.beforeEachHook = hook;
        };
        AnyTouch.prototype.get = function (name) {
            return this._$recognizerMap[name];
        };
        AnyTouch.prototype.set = function (options) {
            this.options = __assign(__assign({}, this.options), options);
        };
        AnyTouch.prototype.destroy = function () {
            this.emit('unbind');
            _super.prototype.destroy.call(this);
        };
        AnyTouch.version = '1.0.13-alpha.0';
        AnyTouch._$Recognizers = [];
        AnyTouch._$computeFunctionMap = {};
        AnyTouch.use = function (Recognizer, recognizerOptions) {
            AnyTouch._$Recognizers.push([Recognizer, recognizerOptions]);
        };
        return AnyTouch;
    }(default_1));

    function resetStatus (recognizer) {
        if ([STATUS_END, STATUS_CANCELLED, STATUS_RECOGNIZED, STATUS_FAILED].includes(recognizer.status)) {
            recognizer.status = STATUS_POSSIBLE;
        }
    }

    function flow(isVaild, lastStatus, stage) {
        var _a, _b, _c, _d, _e, _f, _g;
        var STATE_MAP = {
            1: (_a = {},
                _a[STATUS_POSSIBLE] = (_b = {},
                    _b[INPUT_MOVE] = STATUS_START,
                    _b[INPUT_END] = STATUS_FAILED,
                    _b[INPUT_CANCEL] = STATUS_FAILED,
                    _b),
                _a[STATUS_START] = (_c = {},
                    _c[INPUT_MOVE] = STATUS_MOVE,
                    _c[INPUT_END] = STATUS_END,
                    _c[INPUT_CANCEL] = STATUS_CANCELLED,
                    _c),
                _a[STATUS_MOVE] = (_d = {},
                    _d[INPUT_MOVE] = STATUS_MOVE,
                    _d[INPUT_END] = STATUS_END,
                    _d[INPUT_CANCEL] = STATUS_CANCELLED,
                    _d),
                _a),
            0: (_e = {},
                _e[STATUS_START] = (_f = {},
                    _f[INPUT_MOVE] = STATUS_FAILED,
                    _f[INPUT_END] = STATUS_END,
                    _f[INPUT_CANCEL] = STATUS_CANCELLED,
                    _f),
                _e[STATUS_MOVE] = (_g = {},
                    _g[INPUT_START] = STATUS_FAILED,
                    _g[INPUT_MOVE] = STATUS_FAILED,
                    _g[INPUT_END] = STATUS_END,
                    _g[INPUT_CANCEL] = STATUS_CANCELLED,
                    _g),
                _e)
        };
        var stageToStatusMap = STATE_MAP[Number(isVaild)][lastStatus];
        return void 0 !== stageToStatusMap && stageToStatusMap[stage] || lastStatus;
    }
    function recognizeForPressMoveLike (recognizer, computed, emit) {
        var isVaild = recognizer._$test(computed);
        resetStatus(recognizer);
        var stage = computed.stage;
        recognizer.status = flow(isVaild, recognizer.status, stage);
        recognizer._$isRecognized = [STATUS_START, STATUS_MOVE].includes(recognizer.status);
        var name = recognizer.name, status = recognizer.status, isRecognized = recognizer._$isRecognized;
        if (isRecognized) {
            emit(name);
        }
        if (isRecognized || [STATUS_END, STATUS_CANCELLED].includes(recognizer.status)) {
            emit(name + status);
        }
        return isVaild;
    }

    var default_1$1 = (function () {
        function default_1(options) {
            this.disabled = false;
            this._$isRecognized = false;
            this.status = STATUS_POSSIBLE;
            this.computeFunctions = [];
            this.options = options;
            this.name = this.options.name;
        }
        default_1.prototype.set = function (options) {
            if (void 0 !== options) {
                this.options = __assign(__assign({}, this.options), options);
            }
            return this;
        };
        default_1.prototype._$isValidPointLength = function (pointLength) {
            return this.options.pointLength === pointLength;
        };
        return default_1;
    }());

    var getVLength = (function (v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
    });

    var getDotProduct = (function (v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    });

    var getRadian = (function (v1, v2) {
        var mr = getVLength(v1) * getVLength(v2);
        if (mr === 0)
            return 0;
        var r = getDotProduct(v1, v2) / mr;
        if (r > 1)
            r = 1;
        return Math.acos(r);
    });

    var getCross = (function (v1, v2) {
        return v1.x * v2.y - v2.x * v1.y;
    });

    var radianToAngle = (function (radian) { return radian / Math.PI * 180; });

    var getAngle = (function (v1, v2) {
        var angle = getRadian(v1, v2);
        if (getCross(v1, v2) > 0) {
            angle *= -1;
        }
        return radianToAngle(angle);
    });

    var getDirection = (function (x, y) {
        if (Math.abs(x) >= Math.abs(y)) {
            return 0 < x ? DIRECTION_RIGHT : DIRECTION_LEFT;
        }
        else {
            return 0 < y ? DIRECTION_DOWN : DIRECTION_UP;
        }
    });

    function computeVector(input) {
        return {
            x: input.points[1][CLIENT_X] - input.points[0][CLIENT_X],
            y: input.points[1][CLIENT_Y] - input.points[0][CLIENT_Y]
        };
    }
    function _computeVectorForMutli (input) {
        var prevInput = input.prevInput, startMultiInput = input.startMultiInput;
        if (void 0 !== startMultiInput &&
            void 0 !== prevInput &&
            input.id !== startMultiInput.id &&
            1 < prevInput.pointLength &&
            1 < input.pointLength) {
            return {
                startV: computeVector(startMultiInput),
                prevV: computeVector(prevInput),
                activeV: computeVector(input)
            };
        }
    }

    function ComputeAngle() {
        return function (input) {
            var _vs = (input === null || input === void 0 ? void 0 : input._vs) || _computeVectorForMutli(input);
            if (void 0 !== _vs && _vs.activeV) {
                var prevV = _vs.prevV, startV = _vs.startV, activeV = _vs.activeV;
                var deltaAngle = Math.round(getAngle(activeV, prevV));
                var angle = Math.round(getAngle(activeV, startV));
                return { angle: angle, deltaAngle: deltaAngle, _vs: _vs };
            }
        };
    }
    ComputeAngle._id = "a";

    function ComputeDeltaXY() {
        return function (input) {
            var prevInput = input.prevInput;
            var deltaX = 0;
            var deltaY = 0;
            var deltaXYAngle = 0;
            if (void 0 !== prevInput) {
                deltaX = input.x - prevInput.x;
                deltaY = input.y - prevInput.y;
                if (0 !== deltaX || 0 !== deltaY) {
                    var deltaXY = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                    deltaXYAngle = Math.round(radianToAngle(Math.acos(Math.abs(deltaX) / deltaXY)));
                }
            }
            return { deltaX: deltaX, deltaY: deltaY, deltaXYAngle: deltaXYAngle };
        };
    }
    ComputeDeltaXY._id = "b";

    function ComputeDistance() {
        var displacementX = 0;
        var displacementY = 0;
        var distanceX = 0;
        var distanceY = 0;
        var distance = 0;
        var overallDirection;
        return function (input) {
            var stage = input.stage, startInput = input.startInput;
            if (INPUT_START === stage) {
                displacementX = 0;
                displacementY = 0;
                distanceX = 0;
                distanceY = 0;
                distance = 0;
            }
            else if (INPUT_MOVE === stage) {
                displacementX = Math.round(input.points[0][CLIENT_X] - startInput.points[0][CLIENT_X]);
                displacementY = Math.round(input.points[0][CLIENT_Y] - startInput.points[0][CLIENT_Y]);
                distanceX = Math.abs(displacementX);
                distanceY = Math.abs(displacementY);
                distance = Math.round(getVLength({ x: distanceX, y: distanceY }));
                overallDirection = getDirection(displacementX, displacementY);
            }
            return {
                displacementX: displacementX, displacementY: displacementY, distanceX: distanceX, distanceY: distanceY, distance: distance, overallDirection: overallDirection
            };
        };
    }
    ComputeDistance._id = "c";

    function ComputeMaxLength() {
        var maxPointLength = 0;
        return function (input) {
            var stage = input.stage;
            if (INPUT_START === stage) {
                maxPointLength = input.pointLength;
            }
            return { maxPointLength: maxPointLength };
        };
    }
    ComputeMaxLength._id = "d";

    function ComputeScale() {
        return function (input) {
            var _vs = (input === null || input === void 0 ? void 0 : input._vs) || _computeVectorForMutli(input);
            if (void 0 !== _vs && _vs.activeV) {
                var prevV = _vs.prevV, startV = _vs.startV, activeV = _vs.activeV;
                var deltaScale = round2(getVLength(activeV) / getVLength(prevV));
                var scale = round2(getVLength(activeV) / getVLength(startV));
                return { scale: scale, deltaScale: deltaScale, _vs: _vs };
            }
        };
    }
    ComputeScale._id = "e";

    function ComputeVAndDir() {
        var velocityX = 0;
        var velocityY = 0;
        var speedX = 0;
        var speedY = 0;
        var direction;
        var _lastValidInput;
        return function (input) {
            if (void 0 !== input) {
                var stage = input.stage;
                _lastValidInput = _lastValidInput || input.startInput;
                var deltaTime = input.timestamp - _lastValidInput.timestamp;
                if (INPUT_MOVE === stage && COMPUTE_INTERVAL < deltaTime) {
                    var deltaX = input.x - _lastValidInput.x;
                    var deltaY = input.y - _lastValidInput.y;
                    speedX = Math.round(deltaX / deltaTime * 100) / 100;
                    speedY = Math.round(deltaY / deltaTime * 100) / 100;
                    velocityX = Math.abs(speedX);
                    velocityY = Math.abs(speedY);
                    direction = getDirection(deltaX, deltaY) || direction;
                    _lastValidInput = input;
                }
            }
            return { velocityX: velocityX, velocityY: velocityY, speedX: speedX, speedY: speedY, direction: direction };
        };
    }
    ComputeVAndDir._id = "f";

    var DEFAULT_OPTIONS$1 = {
        name: 'tap',
        pointLength: 1,
        tapTimes: 1,
        waitNextTapTime: 300,
        maxDistance: 2,
        maxDistanceFromPrevTap: 9,
        maxPressTime: 250,
    };
    var default_1$2 = (function (_super) {
        __extends(default_1, _super);
        function default_1(options) {
            var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS$1), options)) || this;
            _this.computeFunctions = [ComputeDistance, ComputeMaxLength];
            _this._$tapCount = 0;
            return _this;
        }
        default_1.prototype._isValidDistanceFromPrevTap = function (center) {
            if (void 0 !== this._$prevTapPoint) {
                var distanceFromPreviousTap = getVLength({ x: center.x - this._$prevTapPoint.x, y: center.y - this._$prevTapPoint.y });
                this._$prevTapPoint = center;
                return this.options.maxDistanceFromPrevTap >= distanceFromPreviousTap;
            }
            else {
                this._$prevTapPoint = center;
                return true;
            }
        };
        default_1.prototype._isValidInterval = function () {
            var now = performance.now();
            if (void 0 === this._$prevTapTime) {
                this._$prevTapTime = now;
                return true;
            }
            else {
                var interval = now - this._$prevTapTime;
                this._$prevTapTime = now;
                return interval < this.options.waitNextTapTime;
            }
        };
        default_1.prototype.recognize = function (computed, emit) {
            var stage = computed.stage, x = computed.x, y = computed.y;
            if (INPUT_END !== stage)
                return;
            this.status = STATUS_POSSIBLE;
            if (this._$test(computed)) {
                clearTimeout(this._$countDownToFailTimer);
                if (this._isValidDistanceFromPrevTap({ x: x, y: y }) && this._isValidInterval()) {
                    this._$tapCount++;
                }
                else {
                    this._$tapCount = 1;
                }
                if (0 === this._$tapCount % this.options.tapTimes) {
                    this.status = STATUS_RECOGNIZED;
                    emit(this.options.name, __assign(__assign({}, computed), { tapCount: this._$tapCount }));
                    this._$reset();
                }
                else {
                    this._$countDownToFail();
                }
            }
            else {
                this._$reset();
                this.status = STATUS_FAILED;
            }
        };
        default_1.prototype._$countDownToFail = function () {
            var _this = this;
            this._$countDownToFailTimer = setTimeout(function () {
                _this.status = STATUS_FAILED;
                _this._$reset();
            }, this.options.waitNextTapTime);
        };
        default_1.prototype._$reset = function () {
            this._$tapCount = 0;
            this._$prevTapPoint = void 0;
            this._$prevTapTime = void 0;
        };
        default_1.prototype._$test = function (computed) {
            var startInput = computed.startInput, pointLength = computed.pointLength;
            var deltaTime = computed.timestamp - startInput.timestamp;
            var maxPointLength = computed.maxPointLength, distance = computed.distance;
            return maxPointLength === this.options.pointLength &&
                0 === pointLength &&
                this.options.maxDistance >= distance &&
                this.options.maxPressTime > deltaTime;
        };
        return default_1;
    }(default_1$1));

    var DEFAULT_OPTIONS$2 = {
        name: 'pan',
        threshold: 10,
        pointLength: 1
    };
    var default_1$3 = (function (_super) {
        __extends(default_1, _super);
        function default_1(options) {
            var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS$2), options)) || this;
            _this.computeFunctions = [ComputeVAndDir, ComputeDistance, ComputeDeltaXY];
            return _this;
        }
        default_1.prototype._$test = function (computed) {
            var pointLength = computed.pointLength, distance = computed.distance;
            return ((this._$isRecognized || this.options.threshold <= distance) &&
                this._$isValidPointLength(pointLength));
        };
        default_1.prototype.recognize = function (computed, emit) {
            var isRecognized = void 0 !== computed.direction && recognizeForPressMoveLike(this, computed, emit);
            if (isRecognized) {
                emit(this.options.name + computed.direction);
            }
        };
        return default_1;
    }(default_1$1));

    var DEFAULT_OPTIONS$3 = {
        name: 'swipe',
        threshold: 10,
        velocity: 0.3,
        pointLength: 1,
    };
    var default_1$4 = (function (_super) {
        __extends(default_1, _super);
        function default_1(options) {
            var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS$3), options)) || this;
            _this.computeFunctions = [ComputeDistance, ComputeVAndDir, ComputeMaxLength];
            return _this;
        }
        default_1.prototype._$test = function (computed) {
            if (INPUT_END !== computed.stage)
                return false;
            var velocityX = computed.velocityX, velocityY = computed.velocityY, maxPointLength = computed.maxPointLength, distance = computed.distance;
            return this.options.pointLength === maxPointLength &&
                this.options.threshold < distance &&
                this.options.velocity < Math.max(velocityX, velocityY);
        };
        default_1.prototype.recognize = function (computed, emit) {
            if (this._$test(computed)) {
                emit(this.options.name);
                emit(this.options.name + computed.direction);
            }
        };
        return default_1;
    }(default_1$1));

    var DEFAULT_OPTIONS$4 = {
        name: 'press',
        pointLength: 1,
        maxDistance: 9,
        minPressTime: 251,
    };
    var default_1$5 = (function (_super) {
        __extends(default_1, _super);
        function default_1(options) {
            var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS$4), options)) || this;
            _this.computeFunctions = [ComputeDistance];
            return _this;
        }
        default_1.prototype.recognize = function (computed, emit) {
            var _this = this;
            var stage = computed.stage, startInput = computed.startInput, pointLength = computed.pointLength;
            if (INPUT_START === stage && this._$isValidPointLength(pointLength)) {
                resetStatus(this);
                this._$cancel();
                this._timeoutId = setTimeout(function () {
                    _this.status = STATUS_RECOGNIZED;
                    emit(_this.options.name);
                }, this.options.minPressTime);
            }
            else if (INPUT_END === stage && STATUS_RECOGNIZED === this.status) {
                emit("" + this.options.name + DIRECTION_UP);
            }
            else if (STATUS_RECOGNIZED !== this.status) {
                var deltaTime = computed.timestamp - startInput.timestamp;
                if (!this._$test(computed) ||
                    (this.options.minPressTime > deltaTime && [INPUT_END, INPUT_CANCEL].includes(stage))) {
                    this._$cancel();
                    this.status = STATUS_FAILED;
                }
            }
        };
        default_1.prototype._$test = function (computed) {
            var distance = computed.distance;
            return this.options.maxDistance > distance;
        };
        default_1.prototype._$cancel = function () {
            clearTimeout(this._timeoutId);
        };
        return default_1;
    }(default_1$1));

    var DEFAULT_OPTIONS$5 = {
        name: 'pinch',
        threshold: 0,
        pointLength: 2,
    };
    var default_1$6 = (function (_super) {
        __extends(default_1, _super);
        function default_1(options) {
            var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS$5), options)) || this;
            _this.computeFunctions = [ComputeScale];
            return _this;
        }
        default_1.prototype._$test = function (computed) {
            var pointLength = computed.pointLength, scale = computed.scale;
            return this._$isValidPointLength(pointLength)
                && void 0 !== scale
                && (this.options.threshold < Math.abs(scale - 1) || this._$isRecognized);
        };
        default_1.prototype.recognize = function (computed, emit) {
            recognizeForPressMoveLike(this, computed, emit);
        };
        return default_1;
    }(default_1$1));

    var DEFAULT_OPTIONS$6 = {
        name: 'rotate',
        threshold: 0,
        pointLength: 2,
    };
    var default_1$7 = (function (_super) {
        __extends(default_1, _super);
        function default_1(options) {
            var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS$6), options)) || this;
            _this.computeFunctions = [ComputeAngle];
            return _this;
        }
        default_1.prototype._$test = function (computed) {
            var pointLength = computed.pointLength, angle = computed.angle;
            return this._$isValidPointLength(pointLength) && (this.options.threshold < Math.abs(angle) || this._$isRecognized);
        };
        default_1.prototype.recognize = function (computed, emit) {
            recognizeForPressMoveLike(this, computed, emit);
        };
        return default_1;
    }(default_1$1));

    AnyTouch.use(default_1$2);
    AnyTouch.use(default_1$3);
    AnyTouch.use(default_1$4);
    AnyTouch.use(default_1$5);
    AnyTouch.use(default_1$6);
    AnyTouch.use(default_1$7);
    AnyTouch.Tap = default_1$2;
    AnyTouch.Pan = default_1$3;
    AnyTouch.Swipe = default_1$4;
    AnyTouch.Press = default_1$5;
    AnyTouch.Pinch = default_1$6;
    AnyTouch.Rotate = default_1$7;
    AnyTouch.STATUS_POSSIBLE = STATUS_POSSIBLE;
    AnyTouch.STATUS_START = STATUS_START;
    AnyTouch.STATUS_MOVE = STATUS_MOVE;
    AnyTouch.STATUS_END = STATUS_END;
    AnyTouch.STATUS_CANCELLED = STATUS_CANCELLED;
    AnyTouch.STATUS_FAILED = STATUS_FAILED;
    AnyTouch.STATUS_RECOGNIZED = STATUS_RECOGNIZED;

    return AnyTouch;

})));
