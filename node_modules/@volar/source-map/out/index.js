"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMap = exports.Mode = void 0;
var Mode;
(function (Mode) {
    /**
     * @case1
     * 123456 -> abcdef
     * ^    ^    ^    ^
     * @case2
     * 123456 -> abcdef
     *  ^  ^      ^  ^
     * @case3
     * 123456 -> abcdef
     *   ^^        ^^
     */
    Mode[Mode["Offset"] = 0] = "Offset";
    /**
     * @case1
     * 123456 -> abcdef
     * ^    ^    ^    ^
     * @case2
     * 123456 -> abcdef
     *  ^  ^     NOT_MATCH
     * @case3
     * 123456 -> abcdef
     *   ^^      NOT_MATCH
     */
    Mode[Mode["Totally"] = 1] = "Totally";
    /**
     * @case1
     * 123456 -> abcdef
     * ^    ^    ^    ^
     * @case2
     * 123456 -> abcdef
     *  ^  ^     ^    ^
     * @case3
     * 123456 -> abcdef
     *   ^^      ^    ^
     */
    Mode[Mode["Expand"] = 2] = "Expand";
    /**
     * @case1
     * 123456 -> abcdef
     * ^     ^   ^    ^
     * @case2
     * 123456 -> abcdef
     *      ^^   ^    ^
     * @case3
     * 123456 -> abcdef
     *       ^^  NOT_MATCH
     */
    Mode[Mode["Overlap"] = 3] = "Overlap";
})(Mode = exports.Mode || (exports.Mode = {}));
class SourceMap extends Set {
    constructor(sourceDocument, mappedDocument, mappings) {
        super(mappings);
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
        this.cache = new Map();
        this.cache2 = new Map();
    }
    // Range
    isSourceRange(start, end) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, true, true).length > 0;
    }
    isMappedRange(start, end) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, false, true).length > 0;
    }
    getSourceRange(start, end) {
        const result = this.getRanges(start, end !== null && end !== void 0 ? end : start, false, true);
        if (result.length)
            return result[0];
    }
    getMappedRange(start, end) {
        const result = this.getRanges(start, end !== null && end !== void 0 ? end : start, true, true);
        if (result.length)
            return result[0];
    }
    getSourceRanges(start, end) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, false);
    }
    getMappedRanges(start, end) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, true);
    }
    getRanges(start, end, sourceToTarget, returnFirstResult) {
        const key = start.line + ':' + start.character + ':' + end.line + ':' + end.character + ':' + sourceToTarget + ':' + returnFirstResult;
        if (this.cache.has(key))
            return this.cache.get(key);
        const toDoc = sourceToTarget ? this.mappedDocument : this.sourceDocument;
        const fromDoc = sourceToTarget ? this.sourceDocument : this.mappedDocument;
        const startOffset = fromDoc.offsetAt(start);
        const endOffset = fromDoc.offsetAt(end);
        const result = this
            .getRanges2(startOffset, endOffset, sourceToTarget, returnFirstResult)
            .map(result => ({
            data: result.data,
            start: toDoc.positionAt(result.start),
            end: toDoc.positionAt(result.end),
        }));
        this.cache.set(key, result);
        return result;
    }
    // MapedRange
    isSourceRange2(start, end) {
        return this.getRanges2(start, end !== null && end !== void 0 ? end : start, true, true).length > 0;
    }
    isMappedRange2(start, end) {
        return this.getRanges2(start, end !== null && end !== void 0 ? end : start, false, true).length > 0;
    }
    getSourceRange2(start, end) {
        const result = this.getRanges2(start, end !== null && end !== void 0 ? end : start, false, true);
        if (result.length)
            return result[0];
    }
    getMappedRange2(start, end) {
        const result = this.getRanges2(start, end !== null && end !== void 0 ? end : start, true, true);
        if (result.length)
            return result[0];
    }
    getSourceRanges2(start, end) {
        return this.getRanges2(start, end !== null && end !== void 0 ? end : start, false);
    }
    getMappedRanges2(start, end) {
        return this.getRanges2(start, end !== null && end !== void 0 ? end : start, true);
    }
    getRanges2(start, end, sourceToTarget, returnFirstResult) {
        const key = start + ':' + end + ':' + sourceToTarget + ':' + returnFirstResult;
        if (this.cache2.has(key))
            return this.cache2.get(key);
        let result = [];
        for (const mapping of this) {
            const maped = this.getRange(start, end, sourceToTarget, mapping.mode, mapping.sourceRange, mapping.mappedRange, mapping.data);
            if (maped) {
                result.push(maped);
                if (returnFirstResult)
                    return result;
            }
            if (mapping.additional) {
                for (const other of mapping.additional) {
                    const maped = this.getRange(start, end, sourceToTarget, other.mode, other.sourceRange, other.mappedRange, mapping.data);
                    if (maped) {
                        result.push(maped);
                        if (returnFirstResult)
                            return result;
                    }
                }
            }
        }
        this.cache2.set(key, result);
        return result;
    }
    getRange(start, end, sourceToTarget, mode, sourceRange, targetRange, data) {
        const mapedToRange = sourceToTarget ? targetRange : sourceRange;
        const mapedFromRange = sourceToTarget ? sourceRange : targetRange;
        if (mode === Mode.Totally) {
            if (start === mapedFromRange.start && end === mapedFromRange.end) {
                const _start = mapedToRange.start;
                const _end = mapedToRange.end;
                return {
                    data: data,
                    start: Math.min(_start, _end),
                    end: Math.max(_start, _end),
                };
            }
        }
        else if (mode === Mode.Offset) {
            if (start >= mapedFromRange.start && end <= mapedFromRange.end) {
                const _start = mapedToRange.start + start - mapedFromRange.start;
                const _end = mapedToRange.end + end - mapedFromRange.end;
                return {
                    data: data,
                    start: Math.min(_start, _end),
                    end: Math.max(_start, _end),
                };
            }
        }
        else if (mode === Mode.Expand) {
            if (start >= mapedFromRange.start && end <= mapedFromRange.end) {
                const _start = mapedToRange.start;
                const _end = mapedToRange.end;
                return {
                    data: data,
                    start: Math.min(_start, _end),
                    end: Math.max(_start, _end),
                };
            }
        }
        else if (mode === Mode.Overlap) {
            if ((start >= mapedFromRange.start && start <= mapedFromRange.end)
                || (end >= mapedFromRange.start && end <= mapedFromRange.end)
                || (mapedFromRange.start >= start && mapedFromRange.start <= end)
                || (mapedFromRange.end >= start && mapedFromRange.end <= end)) {
                const _start = mapedToRange.start;
                const _end = mapedToRange.end;
                return {
                    data: data,
                    start: Math.min(_start, _end),
                    end: Math.max(_start, _end),
                };
            }
        }
    }
}
exports.SourceMap = SourceMap;
//# sourceMappingURL=index.js.map