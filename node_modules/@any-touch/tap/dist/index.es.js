import { __extends, __assign } from 'tslib';
import { INPUT_END, STATUS_POSSIBLE, STATUS_RECOGNIZED, STATUS_FAILED } from '@any-touch/shared';
import Recognizer from '@any-touch/recognizer';
import { getVLength } from '@any-touch/vector';
import { ComputeDistance, ComputeMaxLength } from '@any-touch/compute';

var DEFAULT_OPTIONS = {
    name: 'tap',
    pointLength: 1,
    tapTimes: 1,
    waitNextTapTime: 300,
    maxDistance: 2,
    maxDistanceFromPrevTap: 9,
    maxPressTime: 250,
};
var default_1 = (function (_super) {
    __extends(default_1, _super);
    function default_1(options) {
        var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS), options)) || this;
        _this.computeFunctions = [ComputeDistance, ComputeMaxLength];
        _this._$tapCount = 0;
        return _this;
    }
    default_1.prototype._isValidDistanceFromPrevTap = function (center) {
        if (void 0 !== this._$prevTapPoint) {
            var distanceFromPreviousTap = getVLength({ x: center.x - this._$prevTapPoint.x, y: center.y - this._$prevTapPoint.y });
            this._$prevTapPoint = center;
            return this.options.maxDistanceFromPrevTap >= distanceFromPreviousTap;
        }
        else {
            this._$prevTapPoint = center;
            return true;
        }
    };
    default_1.prototype._isValidInterval = function () {
        var now = performance.now();
        if (void 0 === this._$prevTapTime) {
            this._$prevTapTime = now;
            return true;
        }
        else {
            var interval = now - this._$prevTapTime;
            this._$prevTapTime = now;
            return interval < this.options.waitNextTapTime;
        }
    };
    default_1.prototype.recognize = function (computed, emit) {
        var stage = computed.stage, x = computed.x, y = computed.y;
        if (INPUT_END !== stage)
            return;
        this.status = STATUS_POSSIBLE;
        if (this._$test(computed)) {
            clearTimeout(this._$countDownToFailTimer);
            if (this._isValidDistanceFromPrevTap({ x: x, y: y }) && this._isValidInterval()) {
                this._$tapCount++;
            }
            else {
                this._$tapCount = 1;
            }
            if (0 === this._$tapCount % this.options.tapTimes) {
                this.status = STATUS_RECOGNIZED;
                emit(this.options.name, __assign(__assign({}, computed), { tapCount: this._$tapCount }));
                this._$reset();
            }
            else {
                this._$countDownToFail();
            }
        }
        else {
            this._$reset();
            this.status = STATUS_FAILED;
        }
    };
    default_1.prototype._$countDownToFail = function () {
        var _this = this;
        this._$countDownToFailTimer = setTimeout(function () {
            _this.status = STATUS_FAILED;
            _this._$reset();
        }, this.options.waitNextTapTime);
    };
    default_1.prototype._$reset = function () {
        this._$tapCount = 0;
        this._$prevTapPoint = void 0;
        this._$prevTapTime = void 0;
    };
    default_1.prototype._$test = function (computed) {
        var startInput = computed.startInput, pointLength = computed.pointLength;
        var deltaTime = computed.timestamp - startInput.timestamp;
        var maxPointLength = computed.maxPointLength, distance = computed.distance;
        return maxPointLength === this.options.pointLength &&
            0 === pointLength &&
            this.options.maxDistance >= distance &&
            this.options.maxPressTime > deltaTime;
    };
    return default_1;
}(Recognizer));

export default default_1;
