import { __assign, __rest, __extends, __values, __read } from 'tslib';
import AnyEvent from 'any-event';
import { INPUT_START, INPUT_END, INPUT_CANCEL, CLIENT_X, CLIENT_Y, MOUSE_DOWN, MOUSE_MOVE, INPUT_MOVE, MOUSE_UP, isRegExp, isFunction, TOUCH_START, TOUCH_MOVE, TOUCH_END, TOUCH_CANCEL } from '@any-touch/shared';

function inputCreator () {
    var id = 0;
    var prevInput;
    var activeInput;
    var startInput;
    var startMultiInput;
    return function (basicsInput) {
        prevInput = activeInput;
        if (void 0 !== basicsInput) {
            id = Number.MAX_SAFE_INTEGER > id ? ++id : 1;
            var pureInput = extendInput(basicsInput, id);
            activeInput = pureInput;
            var isStart = pureInput.isStart, pointLength = pureInput.pointLength;
            if (isStart) {
                startInput = pureInput;
                prevInput = void 0;
                if (1 < pointLength) {
                    startMultiInput = pureInput;
                }
                else {
                    startMultiInput = void 0;
                }
            }
            return __assign(__assign({}, pureInput), { prevInput: prevInput, startMultiInput: startMultiInput, startInput: startInput });
        }
    };
}
function getCenter(points) {
    var length = points.length;
    if (0 < length) {
        if (1 === length) {
            var _a = points[0], clientX = _a.clientX, clientY = _a.clientY;
            return { x: Math.round(clientX), y: Math.round(clientY) };
        }
        var countPoint = points.reduce(function (countPoint, point) {
            countPoint.x += point[CLIENT_X];
            countPoint.y += point[CLIENT_Y];
            return countPoint;
        }, { x: 0, y: 0 });
        return { x: Math.round(countPoint.x / length), y: Math.round(countPoint.y / length) };
    }
}
function extendInput(basicsInput, id) {
    var stage = basicsInput.stage, points = basicsInput.points, changedPoints = basicsInput.changedPoints, nativeEvent = basicsInput.nativeEvent;
    var pointLength = points.length;
    var isStart = INPUT_START === stage;
    var isEnd = (INPUT_END === stage && 0 === pointLength) || INPUT_CANCEL === stage;
    var timestamp = Date.now();
    var _a = getCenter(points) || getCenter(changedPoints), x = _a.x, y = _a.y;
    var currentTarget = nativeEvent.currentTarget;
    return Object.assign(basicsInput, {
        id: id,
        x: x, y: y,
        timestamp: timestamp,
        isStart: isStart, isEnd: isEnd,
        pointLength: pointLength,
        currentTarget: currentTarget,
        getOffset: function (el) {
            if (el === void 0) { el = currentTarget; }
            var rect = el.getBoundingClientRect();
            return { x: x - Math.round(rect.left), y: y - Math.round(rect.top) };
        }
    });
}

function mouse () {
    var prevPoints;
    var isPressed = false;
    var _target = null;
    var createInput = inputCreator();
    return function (event) {
        var clientX = event.clientX, clientY = event.clientY, type = event.type, button = event.button, target = event.target;
        var points = [{ clientX: clientX, clientY: clientY, target: target }];
        var stage;
        if (MOUSE_DOWN === type && 0 === button) {
            _target = target;
            isPressed = true;
            stage = INPUT_START;
        }
        else if (isPressed) {
            if (MOUSE_MOVE === type) {
                stage = INPUT_MOVE;
            }
            else if (MOUSE_UP === type) {
                points = [];
                stage = INPUT_END;
                isPressed = false;
            }
        }
        var changedPoints = prevPoints || [{ clientX: clientX, clientY: clientY, target: target }];
        prevPoints = [{ clientX: clientX, clientY: clientY, target: target }];
        if (void 0 !== stage) {
            return createInput({
                stage: stage,
                changedPoints: changedPoints,
                points: points,
                target: _target,
                targets: [_target],
                nativeEvent: event
            });
        }
    };
}

function touch (el) {
    var createInput = inputCreator();
    return function (event) {
        var targets = [];
        var points = [];
        Array.from(event.touches).forEach(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY, target = _a.target;
            if (el === null || el === void 0 ? void 0 : el.contains(target)) {
                targets.push(target);
                points.push({ clientX: clientX, clientY: clientY, target: target });
            }
        });
        var changedPoints = Array.from(event.changedTouches).map(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY, target = _a.target;
            return ({ clientX: clientX, clientY: clientY, target: target });
        });
        return createInput({
            stage: event.type.replace('touch', ''),
            changedPoints: changedPoints,
            points: points,
            nativeEvent: event,
            target: event.target,
            targets: targets
        });
    };
}

function dispatchDomEvent (el, payload, eventInit) {
    var target = payload.target, currentTarget = payload.currentTarget, type = payload.type, data = __rest(payload, ["target", "currentTarget", "type"]);
    var event;
    if (document.createEvent) {
        event = document.createEvent('HTMLEvents');
        event.initEvent(type, eventInit === null || eventInit === void 0 ? void 0 : eventInit.bubbles, eventInit === null || eventInit === void 0 ? void 0 : eventInit.cancelable);
    }
    else {
        event = new Event(type, eventInit);
    }
    Object.assign(event, data, {
        match: function () {
            return payload.targets.every(function (target) {
                return event.currentTarget.contains(target);
            });
        }
    });
    return el.dispatchEvent(event);
}

function canPreventDefault (event, options) {
    if (!options.preventDefault)
        return false;
    var preventDefault = true;
    if (null !== event.target) {
        var preventDefaultExclude = options.preventDefaultExclude;
        if (isRegExp(preventDefaultExclude)) {
            if ('tagName' in event.target) {
                var tagName = event.target.tagName;
                preventDefault = !preventDefaultExclude.test(tagName);
            }
        }
        else if (isFunction(preventDefaultExclude)) {
            preventDefault = !preventDefaultExclude(event);
        }
    }
    return preventDefault;
}

var TOUCH_EVENTS = [TOUCH_START, TOUCH_MOVE, TOUCH_END, TOUCH_CANCEL];
function bindElement (el, catchEvent, options) {
    TOUCH_EVENTS.forEach(function (eventName) {
        el.addEventListener(eventName, catchEvent, options);
    });
    el.addEventListener(MOUSE_DOWN, catchEvent, options);
    window.addEventListener(MOUSE_MOVE, catchEvent, options);
    window.addEventListener(MOUSE_UP, catchEvent, options);
    return function () {
        TOUCH_EVENTS.forEach(function (eventName) {
            el.removeEventListener(eventName, catchEvent);
        });
        el.removeEventListener(MOUSE_DOWN, catchEvent, options);
        window.removeEventListener(MOUSE_MOVE, catchEvent, options);
        window.removeEventListener(MOUSE_UP, catchEvent, options);
    };
}

var AT_AFTER = 'at:after';
function emit2 (at, payload) {
    var type = payload.type, target = payload.target;
    at.emit(type, payload);
    at.emit(AT_AFTER, payload);
    if (!!at.options.domEvents
        && void 0 !== at.el
        && null !== target) {
        dispatchDomEvent(target, payload, at.options.domEvents);
        dispatchDomEvent(target, __assign(__assign({}, payload), { _type: payload.type, type: AT_AFTER }), at.options.domEvents);
    }
}

var DEFAULT_OPTIONS = {
    domEvents: { bubbles: true, cancelable: true },
    preventDefault: true,
    preventDefaultExclude: /^(?:INPUT|TEXTAREA|BUTTON|SELECT)$/,
};
var AT = "at";
var AnyTouch = (function (_super) {
    __extends(AnyTouch, _super);
    function AnyTouch(el, options) {
        var e_1, _a, _b;
        var _this = _super.call(this) || this;
        _this._$computeFunctionMap = {};
        _this._$recognizerMap = {};
        _this._$recognizers = [];
        _this.el = el;
        _this.options = __assign(__assign({}, DEFAULT_OPTIONS), options);
        try {
            for (var _c = __values(AnyTouch._$Recognizers), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), Recognizer_1 = _e[0], options_1 = _e[1];
                _this.use(Recognizer_1, options_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var createInputFromTouch = touch(_this.el);
        var createInputFromMouse = mouse();
        _this._$inputCreatorMap = (_b = {},
            _b[TOUCH_START] = createInputFromTouch,
            _b[TOUCH_MOVE] = createInputFromTouch,
            _b[TOUCH_END] = createInputFromTouch,
            _b[TOUCH_CANCEL] = createInputFromTouch,
            _b[MOUSE_DOWN] = createInputFromMouse,
            _b[MOUSE_MOVE] = createInputFromMouse,
            _b[MOUSE_UP] = createInputFromMouse,
            _b);
        if (void 0 !== el) {
            el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
            var supportsPassive_1 = false;
            try {
                var opts = {};
                Object.defineProperty(opts, 'passive', ({
                    get: function () {
                        supportsPassive_1 = true;
                    }
                }));
                window.addEventListener('_', function () { return void 0; }, opts);
            }
            catch (_f) { }
            _this.on('unbind', bindElement(el, _this.catchEvent.bind(_this), !_this.options.preventDefault && supportsPassive_1 ? { passive: true } : false));
        }
        return _this;
    }
    AnyTouch.prototype.target = function (el) {
        var _this = this;
        return {
            on: function (eventName, listener) {
                _this.on(eventName, listener, function (event) {
                    var targets = event.targets;
                    return targets.every(function (target) { return el.contains(target); });
                });
            }
        };
    };
    AnyTouch.prototype.catchEvent = function (event) {
        var e_2, _a;
        var _this = this;
        var stopPropagation = function () { return event.stopPropagation(); };
        var preventDefault = function () { return event.preventDefault(); };
        var stopImmediatePropagation = function () { return event.stopImmediatePropagation(); };
        if (canPreventDefault(event, this.options)) {
            preventDefault();
        }
        var input = this._$inputCreatorMap[event.type](event);
        if (void 0 !== input) {
            var AT_WITH_STATUS = AT + ':' + input.stage;
            this.emit(AT, input);
            this.emit(AT_WITH_STATUS, input);
            var domEvents = this.options.domEvents;
            if (false !== domEvents) {
                var target = event.target;
                if (null !== target) {
                    dispatchDomEvent(target, __assign(__assign({}, input), { type: AT }), domEvents);
                    dispatchDomEvent(target, __assign(__assign({}, input), { type: AT_WITH_STATUS }), domEvents);
                }
            }
            var computed_1 = input;
            for (var k in this._$computeFunctionMap) {
                Object.assign(computed_1, this._$computeFunctionMap[k](computed_1));
            }
            var _loop_1 = function (recognizer) {
                if (recognizer.disabled)
                    return "continue";
                recognizer.recognize(computed_1, function (type) {
                    var payload = __assign(__assign({}, computed_1), { type: type, name: recognizer.name, stopPropagation: stopPropagation,
                        preventDefault: preventDefault,
                        stopImmediatePropagation: stopImmediatePropagation });
                    Object === null || Object === void 0 ? void 0 : Object.freeze(payload);
                    if (void 0 === _this.beforeEachHook) {
                        emit2(_this, payload);
                    }
                    else {
                        _this.beforeEachHook(recognizer, _this._$recognizerMap, function () {
                            emit2(_this, payload);
                        });
                    }
                });
            };
            try {
                for (var _b = __values(this._$recognizers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var recognizer = _c.value;
                    _loop_1(recognizer);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    AnyTouch.prototype.use = function (Recognizer, recognizerOptions) {
        var e_3, _a;
        var name = recognizerOptions === null || recognizerOptions === void 0 ? void 0 : recognizerOptions.name;
        if (void 0 !== name && void 0 !== this._$recognizerMap[name])
            return;
        var recognizer = new Recognizer(recognizerOptions);
        try {
            for (var _b = __values(recognizer.computeFunctions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var createComputeFunction = _c.value;
                var _id = createComputeFunction._id;
                if (void 0 === this._$computeFunctionMap[_id]) {
                    this._$computeFunctionMap[_id] = createComputeFunction();
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        this._$recognizerMap[recognizer.name] = recognizer;
        this._$recognizers.push(this._$recognizerMap[recognizer.name]);
    };
    AnyTouch.prototype.removeUse = function (recognizerName) {
        var e_4, _a;
        if (void 0 === recognizerName) {
            this._$recognizers = [];
            this._$recognizerMap = {};
        }
        else {
            try {
                for (var _b = __values(this._$recognizers.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), index = _d[0], recognizer = _d[1];
                    if (recognizerName === recognizer.options.name) {
                        this._$recognizers.splice(index, 1);
                        delete this._$recognizerMap[recognizerName];
                        break;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    };
    AnyTouch.prototype.beforeEach = function (hook) {
        this.beforeEachHook = hook;
    };
    AnyTouch.prototype.get = function (name) {
        return this._$recognizerMap[name];
    };
    AnyTouch.prototype.set = function (options) {
        this.options = __assign(__assign({}, this.options), options);
    };
    AnyTouch.prototype.destroy = function () {
        this.emit('unbind');
        _super.prototype.destroy.call(this);
    };
    AnyTouch.version = '1.0.13-alpha.0';
    AnyTouch._$Recognizers = [];
    AnyTouch._$computeFunctionMap = {};
    AnyTouch.use = function (Recognizer, recognizerOptions) {
        AnyTouch._$Recognizers.push([Recognizer, recognizerOptions]);
    };
    return AnyTouch;
}(AnyEvent));

export default AnyTouch;
