import { getAngle, radianToAngle, getVLength, getDirection } from '@any-touch/vector';
import { CLIENT_X, CLIENT_Y, INPUT_START, INPUT_MOVE, round2, COMPUTE_INTERVAL } from '@any-touch/shared';

function computeVector(input) {
    return {
        x: input.points[1][CLIENT_X] - input.points[0][CLIENT_X],
        y: input.points[1][CLIENT_Y] - input.points[0][CLIENT_Y]
    };
}
function _computeVectorForMutli (input) {
    var prevInput = input.prevInput, startMultiInput = input.startMultiInput;
    if (void 0 !== startMultiInput &&
        void 0 !== prevInput &&
        input.id !== startMultiInput.id &&
        1 < prevInput.pointLength &&
        1 < input.pointLength) {
        return {
            startV: computeVector(startMultiInput),
            prevV: computeVector(prevInput),
            activeV: computeVector(input)
        };
    }
}

function ComputeAngle() {
    return function (input) {
        var _vs = (input === null || input === void 0 ? void 0 : input._vs) || _computeVectorForMutli(input);
        if (void 0 !== _vs && _vs.activeV) {
            var prevV = _vs.prevV, startV = _vs.startV, activeV = _vs.activeV;
            var deltaAngle = Math.round(getAngle(activeV, prevV));
            var angle = Math.round(getAngle(activeV, startV));
            return { angle: angle, deltaAngle: deltaAngle, _vs: _vs };
        }
    };
}
ComputeAngle._id = "a";

function ComputeDeltaXY() {
    return function (input) {
        var prevInput = input.prevInput;
        var deltaX = 0;
        var deltaY = 0;
        var deltaXYAngle = 0;
        if (void 0 !== prevInput) {
            deltaX = input.x - prevInput.x;
            deltaY = input.y - prevInput.y;
            if (0 !== deltaX || 0 !== deltaY) {
                var deltaXY = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                deltaXYAngle = Math.round(radianToAngle(Math.acos(Math.abs(deltaX) / deltaXY)));
            }
        }
        return { deltaX: deltaX, deltaY: deltaY, deltaXYAngle: deltaXYAngle };
    };
}
ComputeDeltaXY._id = "b";

function ComputeDistance() {
    var displacementX = 0;
    var displacementY = 0;
    var distanceX = 0;
    var distanceY = 0;
    var distance = 0;
    var overallDirection;
    return function (input) {
        var stage = input.stage, startInput = input.startInput;
        if (INPUT_START === stage) {
            displacementX = 0;
            displacementY = 0;
            distanceX = 0;
            distanceY = 0;
            distance = 0;
        }
        else if (INPUT_MOVE === stage) {
            displacementX = Math.round(input.points[0][CLIENT_X] - startInput.points[0][CLIENT_X]);
            displacementY = Math.round(input.points[0][CLIENT_Y] - startInput.points[0][CLIENT_Y]);
            distanceX = Math.abs(displacementX);
            distanceY = Math.abs(displacementY);
            distance = Math.round(getVLength({ x: distanceX, y: distanceY }));
            overallDirection = getDirection(displacementX, displacementY);
        }
        return {
            displacementX: displacementX, displacementY: displacementY, distanceX: distanceX, distanceY: distanceY, distance: distance, overallDirection: overallDirection
        };
    };
}
ComputeDistance._id = "c";

function ComputeMaxLength() {
    var maxPointLength = 0;
    return function (input) {
        var stage = input.stage;
        if (INPUT_START === stage) {
            maxPointLength = input.pointLength;
        }
        return { maxPointLength: maxPointLength };
    };
}
ComputeMaxLength._id = "d";

function ComputeScale() {
    return function (input) {
        var _vs = (input === null || input === void 0 ? void 0 : input._vs) || _computeVectorForMutli(input);
        if (void 0 !== _vs && _vs.activeV) {
            var prevV = _vs.prevV, startV = _vs.startV, activeV = _vs.activeV;
            var deltaScale = round2(getVLength(activeV) / getVLength(prevV));
            var scale = round2(getVLength(activeV) / getVLength(startV));
            return { scale: scale, deltaScale: deltaScale, _vs: _vs };
        }
    };
}
ComputeScale._id = "e";

function ComputeVAndDir() {
    var velocityX = 0;
    var velocityY = 0;
    var speedX = 0;
    var speedY = 0;
    var direction;
    var _lastValidInput;
    return function (input) {
        if (void 0 !== input) {
            var stage = input.stage;
            _lastValidInput = _lastValidInput || input.startInput;
            var deltaTime = input.timestamp - _lastValidInput.timestamp;
            if (INPUT_MOVE === stage && COMPUTE_INTERVAL < deltaTime) {
                var deltaX = input.x - _lastValidInput.x;
                var deltaY = input.y - _lastValidInput.y;
                speedX = Math.round(deltaX / deltaTime * 100) / 100;
                speedY = Math.round(deltaY / deltaTime * 100) / 100;
                velocityX = Math.abs(speedX);
                velocityY = Math.abs(speedY);
                direction = getDirection(deltaX, deltaY) || direction;
                _lastValidInput = input;
            }
        }
        return { velocityX: velocityX, velocityY: velocityY, speedX: speedX, speedY: speedY, direction: direction };
    };
}
ComputeVAndDir._id = "f";

export { ComputeAngle, ComputeDeltaXY, ComputeDistance, ComputeMaxLength, ComputeScale, ComputeVAndDir };
